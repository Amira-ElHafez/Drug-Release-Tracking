# -*- coding: utf-8 -*-
"""error.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Dppko3t6fxrwPa7U3Zdw_gaQ5Vpy8HOl
"""

# DRUG RELEASE MODEL: FD vs FVM vs FEM with Error Comparison

# ───────────────────────────────────────────────────────────────
# 1. IMPORTS AND GLOBAL PARAMETERS
# ───────────────────────────────────────────────────────────────
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
import time

# Common model parameters
D = 0.6
E = 0.2
alpha = 0.2
beta = 1.0
gamma = 1.0
kr = 1.0
ua = 0.0
ub = 1.0
vb = 1.0

# Spatial grid
Nx = 26
x = np.linspace(-0.5, 0.5, Nx)
dx = x[1] - x[0]

# Snapshot times
t_snap = np.array([0.0, 0.4, 0.8, 1.2, 1.6, 2.0])
Nt = len(t_snap)

def f(u, v):
    return -u * (ub - u) + v * (vb - v)

def g(u, v):
    return  u * (ub - u) - v * (vb - v)

# ───────────────────────────────────────────────────────────────
# 2. METHOD OF LINES (FD - STAGEWISE)
# ───────────────────────────────────────────────────────────────
def dss004(xl, xu, n, u):
    dx = (xu - xl) / (n - 1)
    ux = np.zeros(n)
    for i in range(2, n-2):
        ux[i] = (-u[i+2] + 8*u[i+1] - 8*u[i-1] + u[i-2]) / (12*dx)
    ux[0] = (-25*u[0] + 48*u[1] - 36*u[2] + 16*u[3] - 3*u[4]) / (12*dx)
    ux[1] = (-3*u[0] - 10*u[1] + 18*u[2] - 6*u[3] + u[4]) / (12*dx)
    ux[-2] = (-u[-5] + 6*u[-4] - 18*u[-3] + 10*u[-2] + 3*u[-1]) / (12*dx)
    ux[-1] = (3*u[-5] - 16*u[-4] + 36*u[-3] - 48*u[-2] + 25*u[-1]) / (12*dx)
    return ux

def drug_fd(t, U):
    u, v, s = U[:Nx], U[Nx:2*Nx], U[2*Nx:]
    ux = dss004(-0.5, 0.5, Nx, u)
    sx = dss004(-0.5, 0.5, Nx, s)
    ux[0] = -(kr/D)*(ua - u[0]); ux[-1] = (kr/D)*(ua - u[-1])
    sx[0] = 0; sx[-1] = 0
    uxx = dss004(-0.5, 0.5, Nx, ux)
    sxx = dss004(-0.5, 0.5, Nx, sx)
    ut = D*uxx + E*sxx + f(u, v)
    vt = g(u, v)
    st = alpha*u - beta*s + gamma*ut
    return np.concatenate([ut, vt, st])

u0_fd = np.full(Nx, 0.75)
v0_fd = np.full(Nx, 0.25)
s0_fd = np.zeros(Nx)
U0_fd = np.concatenate([u0_fd, v0_fd, s0_fd])
t0 = time.time()
sol_fd = solve_ivp(drug_fd, [0, 2], U0_fd, t_eval=t_snap, method='LSODA')
t_fd = time.time() - t0
u_fd, v_fd, s_fd = sol_fd.y[:Nx].T, sol_fd.y[Nx:2*Nx].T, sol_fd.y[2*Nx:].T

# ───────────────────────────────────────────────────────────────
# 3. FINITE VOLUME METHOD (FVM)
# ───────────────────────────────────────────────────────────────
xg = np.linspace(-0.5 + dx/2, 0.5 - dx/2, Nx)

def fvm_flux(u, s):
    F_u = np.zeros(Nx+1)
    F_s = np.zeros(Nx+1)
    F_u[0] = kr * (ua - u[0])
    F_s[0] = 0.0
    F_u[-1] = -kr * (ua - u[-1])
    F_s[-1] = 0.0
    for i in range(1, Nx):
        F_u[i] = -D * (u[i] - u[i-1]) / dx
        F_s[i] = -E * (s[i] - s[i-1]) / dx
    return F_u, F_s

def drug_fvm(t, U):
    u, v, s = U[:Nx], U[Nx:2*Nx], U[2*Nx:]
    F_u, F_s = fvm_flux(u, s)
    du = np.array([(F_u[i] - F_u[i+1]) / dx + (F_s[i] - F_s[i+1]) / dx + f(u[i], v[i]) for i in range(Nx)])
    dv = g(u, v)
    ds = alpha*u - beta*s + gamma*du
    return np.concatenate([du, dv, ds])

U0_fvm = np.concatenate([u0_fd, v0_fd, s0_fd])
t0 = time.time()
sol_fvm = solve_ivp(drug_fvm, [0, 2], U0_fvm, t_eval=t_snap, method='LSODA')
t_fvm = time.time() - t0
u_fvm, v_fvm, s_fvm = sol_fvm.y[:Nx].T, sol_fvm.y[Nx:2*Nx].T, sol_fvm.y[2*Nx:].T

# ───────────────────────────────────────────────────────────────
# 4. FINITE ELEMENT METHOD (FEM)
# ───────────────────────────────────────────────────────────────
def fem_matrices(Nx, dx):
    M = np.zeros((Nx, Nx)); K = np.zeros((Nx, Nx))
    for i in range(Nx - 1):
        Mloc = dx / 6 * np.array([[2, 1], [1, 2]])
        Kloc = 1 / dx * np.array([[1, -1], [-1, 1]])
        for a in range(2):
            for b in range(2):
                M[i+a, i+b] += Mloc[a, b]
                K[i+a, i+b] += Kloc[a, b]
    return M, K

M, K_u = fem_matrices(Nx, dx)
_, K_s = fem_matrices(Nx, dx)
K_u[0, 0] += kr / D; K_u[-1, -1] += kr / D

# FEM RHS
def rhs_fem(t, y):
    u, v, s = y[:Nx], y[Nx:2*Nx], y[2*Nx:]
    fu = f(u, v); gu = g(u, v)
    rhs_u = -D * (K_u @ u) - E * (K_s @ s) + M @ fu
    rhs_u[0] += kr * ua; rhs_u[-1] += kr * ua
    du = np.linalg.solve(M, rhs_u)
    dv = gu
    ds = -beta*s + alpha*u + gamma*du
    return np.concatenate([du, dv, ds])

U0_fem = np.concatenate([u0_fd, v0_fd, s0_fd])
t0 = time.time()
sol_fem = solve_ivp(rhs_fem, [0, 2], U0_fem, t_eval=t_snap, method='BDF')
t_fem = time.time() - t0
u_fem, v_fem, s_fem = sol_fem.y[:Nx].T, sol_fem.y[Nx:2*Nx].T, sol_fem.y[2*Nx:].T

# ───────────────────────────────────────────────────────────────
# 5. RELATIVE ERROR COMPARISON
# ───────────────────────────────────────────────────────────────
def compute_relative_error(ref, target):
    return np.abs((target - ref) / (np.abs(ref) + 1e-8)) * 100

def compute_avg_errors(ref_u, ref_v, ref_s, method_u, method_v, method_s):
    avg_err_u, avg_err_v, avg_err_s = [], [], []
    for i in range(len(t_snap)):
        err_u = compute_relative_error(ref_u[:, i], method_u[:, i])
        err_v = compute_relative_error(ref_v[:, i], method_v[:, i])
        avg_err_u.append(np.mean(err_u))
        avg_err_v.append(np.mean(err_v))
        if i > 0:
            err_s = compute_relative_error(ref_s[:, i], method_s[:, i])
            avg_err_s.append(np.mean(err_s))
        else:
            avg_err_s.append(None)
    return avg_err_u, avg_err_v, avg_err_s

def print_full_comparison_table(uerr_fvm, verr_fvm, serr_fvm, uerr_fem, verr_fem, serr_fem):
    print("\nFull Relative Error Comparison Table (vs FD/MOL)\n")
    print(f"{'Time':>6} | {'Method':>6} | {'u(%)':>8} | {'v(%)':>8} | {'σ(%)':>8}")
    print("-" * 44)
    for i, t in enumerate(t_snap):
        print(f"{t:6.2f} | {'FD':>6} | {0.0:8.3f} | {0.0:8.3f} | {'  ---  ' if i == 0 else f'{0.0:8.3f}' }")
        print(f"{'':6} | {'FVM':>6} | {uerr_fvm[i]:8.3f} | {verr_fvm[i]:8.3f} | {'  ---  ' if serr_fvm[i] is None else f'{serr_fvm[i]:8.3f}' }")
        print(f"{'':6} | {'FEM':>6} | {uerr_fem[i]:8.3f} | {verr_fem[i]:8.3f} | {'  ---  ' if serr_fem[i] is None else f'{serr_fem[i]:8.3f}' }")
        print("-" * 44)

# Calculate and print
uerr_fvm, verr_fvm, serr_fvm = compute_avg_errors(u_fd, v_fd, s_fd, u_fvm, v_fvm, s_fvm)
uerr_fem, verr_fem, serr_fem = compute_avg_errors(u_fd, v_fd, s_fd, u_fem, v_fem, s_fem)
print_full_comparison_table(uerr_fvm, verr_fvm, serr_fvm, uerr_fem, verr_fem, serr_fem)

# Print compute time summary
print("\nCompute Time (seconds):")
print(f"FD (MOL): {t_fd:.4f} s")
print(f"FVM     : {t_fvm:.4f} s")
print(f"FEM     : {t_fem:.4f} s")